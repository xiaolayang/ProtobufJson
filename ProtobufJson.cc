#include <getopt.h>
#include <strings.h>
#include <wordexp.h>
#include <iostream>
#include <sstream>
#include <filesystem>
#include <fstream>
#include <queue>
#include <type_traits>
#include <google/protobuf/compiler/importer.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/util/json_util.h>
#include <google/protobuf/dynamic_message.h>
#include <google/protobuf/stubs/strutil.h>
#include <string>
#include <vector>
#include <map>
#include <regex>  
#include <unordered_map>
using namespace std::string_literals; // enables s-suffix for std::string literals
using namespace google::protobuf::compiler;
using namespace google::protobuf::util;
using google::protobuf::FileDescriptor;
using google::protobuf::FileDescriptorSet;
using google::protobuf::Descriptor;
using google::protobuf::DynamicMessageFactory;
using google::protobuf::Message;
using google::protobuf::Base64Unescape;
using google::protobuf::DescriptorPool;
using google::protobuf::Reflection;
using google::protobuf::FieldDescriptor;
using google::protobuf::OneofDescriptor;
/**
 * Convertion Type.
 */
enum EnumConvertType {
  JSON_TO_PROTO = 0,
  PROTO_TO_JSON,
  JSON_TO_HEADER,
};
/**
 * Command line options for this program.
 */
struct Options {
  /**
   * If verbose > 0, print debugging information to stderr.
   */
  int verbose;

  /**
   * True means that we are converting protobuf to JSON. False means we are
   * converting JSON to Protobuf.
   */
  EnumConvertType convertType;

  /**
   * A list of directories to look for proto files in when resolving imports.
   * Imports must be rooted at one of these directories.
   * If omitted, the current working directory is assumed.
   */
  std::vector<const char*> protoPaths;

  /**
   * A list of root proto files to search over, as relative paths from the
   * protoPaths. These files and their dependencies will be searched over. If
   * not provided, all proto files in the protoPaths will be searched.
   */
  std::vector<const char*> protoFiles;

  /**
   * A list of proto descriptor sets generated by invoking `protoc` with
   * `--descriptor_set_out`.
   */
  std::vector<const char*> descriptorSets;

  /**
   * The name of the protobuf message we wish to convert to or from json.
   */
  const char* messageName;

  /**
   * If given, this is either literal data provided on the command line or a
   * filename.
   * If not given, our converter reads from stdin.
   */
  const char* data;

  /**
   * The name of the data struct we wish to convert to or from json.
   */
  const char* structName;
};

/**
 * Print usage to stderr and exit.
 */
static void usage(const char* progName, bool isHelp = 0) {
  fprintf(stderr,
       "Usage: %s [--proto_path=PATH...] [--verbose] <message_name> [data] \n"
       "\n"
       "  There are two names for this tool:\n"
       "    JsonToProto will assume the input is JSON and write binary protobuf to stdout.\n"
       "    ProtoToJson will assume the input is Proto and write JSON to stdout.\n"
       "    JsonToHeader will assume the input is JSON and write C++ header to stdout.\n"
       "\n"
       "  Arguments:\n"
       "    -IPATH, --proto_path=PATH   Specify the directory in which to search for\n"
       "                                imports.  May be specified multiple times;\n"
       "                                directories will be searched in order.  If not\n"
       "                                given, the current working directory is used.\n"
       "    -P file, --proto_file=PATH  Specify the path of the file defining the protobuf \n"
       "                                message we wish to convert to or from json, relative to\n"
       "                                any of the proto_path options. This is an optimization.\n"
       "                                This option is only consumed when `--proto_path` is given.\n"
       "    --descriptor_set <DS>       Specify one or more descriptor sets produced by running\n"
       "                                `protoc` with `--descriptor_set_out`. This option is\n"
       "                                ignored if `--proto_path` is given.\n"
       "    --verbose                   When given, debug output will be printed to stderr.\n"
       "    message_name                The name of the protobuf message we wish to convert to or from json.\n"
       "    data                        If not provided as an argument, input is read from stdin.\n"
       "                                If provided, it is interpreted as a filename if it is prefixed\n"
       "                                with the `@` symbol, and otherwise as literal data.\n"
       "                                For json to proto, literal data is interpreted as JSON.\n"
       "                                For proto to json, literal data is interpreted as base64\n"
       "                                encoded protobuf.\n"
       "    --help                      Show this message.\n",
      progName);
  if (isHelp) {
    exit(0);
  }
  exit(1);
}

/**
 * Attempt to parse command line arguments. Print out an informative message to
 * stderr if an error is encountered.
 */
Options parseArguments(int argc, char** argv) {
  // Ensure that we have enough arguments for all required arguments.
  if (argc < 2 ) {
    fprintf(stderr, "Not enough arguments.\n");
    usage(argv[0]);
  }

  // Retain the orignal argc and argv for verbose printing.
  int oldArgc = argc;
  char** oldArgv = argv;

  // Initialize default options
  Options options;
  options.verbose = 0;
  options.convertType = EnumConvertType::JSON_TO_PROTO;
  options.messageName = NULL;
  options.data = NULL;
  options.structName = NULL;

  // Get the name without the path
  const char* exeName = strrchr(argv[0], '/');
  if (exeName) {
    exeName++;
  } else {
    exeName = argv[0];
  }
  if (strcasecmp("JsonToProto", exeName) == 0) {
    options.convertType = EnumConvertType::JSON_TO_PROTO;
  } else if (strcasecmp("ProtoToJson", exeName) == 0) {
    options.convertType = EnumConvertType::PROTO_TO_JSON;
  } else if (strcasecmp("JsonToHeader", exeName) == 0) {
    options.convertType = EnumConvertType::JSON_TO_HEADER;
  } else {
    fprintf(stderr, "Please invoke this binary as JsonToProto or ProtoToJson.\n");
    usage(oldArgv[0]);
  }

  static struct option long_options[] =
    {
      /* These options set a flag. */
      {"verbose", no_argument, &options.verbose, 1},
      {"proto_path", required_argument, 0, 'I'},
      {"proto_file", required_argument, 0, 'P'},
      {"descriptor_set", required_argument, 0, 'D'},
      {"help", no_argument, NULL, 'h'},
      {0, 0, 0, 0}
    };
  while (1) {
    int option_index = 0;
    int c;
    c = getopt_long(argc, argv, "hI:P:D:", long_options, &option_index);
    if (c == -1) {
      break;
    }
    switch (c) {
      // Do nothing if just set verbose flag
      case 0:
        break;
      case 'I':
        options.protoPaths.push_back(optarg);
        break;
      case 'P':
        options.protoFiles.push_back(optarg);
        break;
      case 'D':
        options.descriptorSets.push_back(optarg);
        break;
      case '?':
        /* getopt_long already printed an error message. */
        break;
      case 'h':
        usage(oldArgv[0], 1);
      default:
        usage(oldArgv[0]);
    }
  }
  argc -= optind;
  argv += optind;

  // Make the protoPaths the current directory if there are neither descriptor
  // sets nor protoPaths specified on the command line.
  if (options.protoPaths.empty() && options.descriptorSets.empty()) {
    options.protoPaths.push_back(".");
  }

  // Parse mandatory arguments and optional positional argument.
  if (argc < 1) {
    fprintf(stderr, "Missing mandatory positional arguments.\n");
    usage(oldArgv[0]);
  }

  options.messageName = argv[0];

  if (argc > 1) {
    options.data = argv[1];
  }
  if (argc > 2) {
    options.structName = argv[2];
  }
  

  // Print options output to debug option parsing.
  if (options.verbose) {
    fprintf(stderr, "argc: %d\nargv:\n", oldArgc);
    for (int i = 0; i < oldArgc; i++) {
      fprintf(stderr, "\t%d: %s\n", i, oldArgv[i]);
    }

    fprintf(stderr, "Options:\n");
    fprintf(stderr, "\tType: %d\n", options.convertType);
    fprintf(stderr, "\tverbose: %d\n", options.verbose);
    fprintf(stderr, "\tproto_path:\n");
    for (int i = 0; i < options.protoPaths.size(); i++) {
      fprintf(stderr, "\t\t%s\n", options.protoPaths[i]);
    }
    fprintf(stderr, "\tproto_file:\n");
    for (int i = 0; i < options.protoFiles.size(); i++) {
      fprintf(stderr, "\t\t%s\n", options.protoFiles[i]);
    }
    fprintf(stderr, "\tdescriptor_set:\n");
    for (int i = 0; i < options.descriptorSets.size(); i++) {
      fprintf(stderr, "\t\t%s\n", options.descriptorSets[i]);
    }

    fprintf(stderr, "\tmessage_name: %s\n", options.messageName);
    fprintf(stderr, "\tdata: %s\n", options.data);
    fprintf(stderr, "\tstruct_name: %s\n", options.structName);
  }
  return options;
}

/**
 * Read all the bytes of a string.
 */
std::string readFile(std::string filename) {
  constexpr auto read_size = std::size_t(4096);
  auto stream = std::ifstream(filename);
  stream.exceptions(std::ios_base::badbit);

  if (not stream) {
    throw std::ios_base::failure("file does not exist");
  }

  auto out = std::string();
  auto buf = std::string(read_size, '\0');
  while (stream.read(& buf[0], read_size)) {
    out.append(buf, 0, stream.gcount());
  }
  out.append(buf, 0, stream.gcount());
  return out;
}
/**
 * Add the message types in a file descriptor to a map of fully qualified
 * message names to descriptors.
 */
void importFileDescriptor(const FileDescriptor* fd,
    std::map<std::string, const Descriptor*>& messageDescriptors) {
  std::string packageName = fd->package();
  if (!packageName.empty()) {
    packageName += ".";
  }
  for (int i = 0; i < fd->message_type_count(); i++) {
    const Descriptor* messageDescriptor = fd->message_type(i);
    std::string messageDescriptorFullName = packageName + messageDescriptor->name();
    messageDescriptors[messageDescriptorFullName] = messageDescriptor;

    // Add nested messages with a BFS.
    std::queue<std::string> q;
    q.push(messageDescriptorFullName);
    while (!q.empty()) {
      std::string messageName = q.front();
      q.pop();
      const Descriptor* descriptor = messageDescriptors[messageName];
      for (int j = 0; j < descriptor->nested_type_count(); j++) {
        std::string childMessageName = messageName;
        childMessageName += ".";
        childMessageName += descriptor->nested_type(j)->name();
        messageDescriptors[childMessageName] = descriptor->nested_type(j);
        q.push(childMessageName);
      }
    }
  }
}

// Return a pointer to a message
std::shared_ptr<Message> * createMessageSharedPtr(const Message &message) {
    Message *copy = message.New();
    copy->CopyFrom(message);
    void *ptr = new std::shared_ptr<Message>(copy);
    std::shared_ptr<Message> *msg = static_cast<std::shared_ptr<Message> *>(ptr);
    return msg;
}
// Replace some special characters to underscore letter
std::string replaceSpeicalWithUnscoreChar(const std::string str) {
  return std::regex_replace(str, std::regex("([\\.\\!\\/;@%])"), "_");
}
// Function to convert camel case string to snake case string.
std::string camelToSnake(std::string camelString)  
{  
    std::regex pattern("([a-z\\d])([A-Z])");  
    std::string replacement = "$1_$2";  
    std::string snakeString = std::regex_replace(camelString, pattern, replacement);  
    return snakeString;  
}  
// Convert to upper case snaked string
std::string convertNameString(const std::string name)  
{  
    // Replace some special characters to underscore letter
    const std::string str_1 = replaceSpeicalWithUnscoreChar(name);
    std::string str_2 = camelToSnake(str_1);
    std::transform(str_2.begin(), str_2.end(), str_2.begin(), ::toupper);
    return str_2;
}
template <typename T>
bool getDataTypeName (std::string &value_type_name) {
    if(std::is_same_v<T, int64_t>)
      value_type_name = "int64_t";
    else if(std::is_same_v<T, uint64_t>) 
      value_type_name = "uint64_t";
    else if(std::is_same_v<T, int32_t>) 
      value_type_name = "int32_t";
    else if(std::is_same_v<T, uint32_t>) 
      value_type_name = "uint32_t";
    else if(std::is_same_v<T, float>) 
      value_type_name = "float"; 
    else if(std::is_same_v<T, double>) 
      value_type_name = "double"; 
    else if(std::is_same_v<T, std::string>) 
      value_type_name = "std::string";
    else { // Not supported enum type
      return false;
    }
    return true;
}
template <typename T>
bool getValueTypeName (std::string &value_type_name) {
    if(std::is_same_v<T, int64_t>)
      value_type_name = "int64_value";
    else if(std::is_same_v<T, uint64_t>) 
      value_type_name = "uint64_value";
    else if(std::is_same_v<T, int32_t>) 
      value_type_name = "int32_value";
    else if(std::is_same_v<T, uint32_t>) 
      value_type_name = "uint32_value";
    else if(std::is_same_v<T, float>) 
      value_type_name = "float_value"; 
    else if(std::is_same_v<T, double>) 
      value_type_name = "double_value";       
    else if(std::is_same_v<T, std::string>)
      value_type_name = "string_value";
    else { // Not supported enum type
      return false;
    }
    return true;
}
template <typename T>
bool getMessageFieldValue(std::shared_ptr<Message> m, const std::string &field_name, T &value, bool oneof_field = false) {
    const Descriptor *desc       = m->GetDescriptor();
    const Reflection *refl       = m->GetReflection();   
    int fieldCount= desc->field_count();
    bool rtn = false;
   
    for(int i=0;i<fieldCount;i++) {
      const FieldDescriptor *field = desc->field(i);
      if (oneof_field) {
        // Get the oneof field descriptor
        const OneofDescriptor * oneof_descriptor = field->containing_oneof();//desc->oneof_decl(i);
        if(oneof_descriptor != nullptr && refl->HasOneof(*m, oneof_descriptor))
        {
          field = refl->GetOneofFieldDescriptor(*m,oneof_descriptor);
        }
        else {
          continue;
        }
      }

      if(!field->is_repeated() && (field_name.empty() || field->name() == field_name)){
 
        if((std::is_same_v<T, double>) && field->type() == FieldDescriptor::TYPE_DOUBLE) {
          value = refl->GetDouble(*m, field);
          rtn = true;
          break;
        }
        else if((std::is_same_v<T, float>) && field->type() == FieldDescriptor::TYPE_FLOAT) {
          value = refl->GetFloat(*m, field);
          rtn = true;
          break;
        }
        else if((std::is_same_v<T, int64_t>) && field->type() == FieldDescriptor::TYPE_INT64) {
          value = refl->GetInt64(*m, field);
          rtn = true;
          break;

        }
        else if((std::is_same_v<T, int32_t>) && (field->type() == FieldDescriptor::TYPE_INT32 ||
        field->type() == FieldDescriptor::TYPE_ENUM)) {
          if (field->type() == FieldDescriptor::TYPE_INT32)
            value = refl->GetInt32(*m, field);
          else
            value = refl->GetEnumValue(*m, field);
          rtn = true;
          break;
        }
        else if((std::is_same_v<T, uint64_t>) && field->type() == FieldDescriptor::TYPE_UINT64) {
          value = refl->GetUInt64(*m, field);
          rtn = true;
          break;
        }
        else if((std::is_same_v<T, uint32_t>) && (field->type() == FieldDescriptor::TYPE_UINT32 || 
        field->type() == FieldDescriptor::TYPE_ENUM) ){
          if (field->type() == FieldDescriptor::TYPE_UINT32 ) 
            value = refl->GetUInt32(*m, field);
          else
            value = refl->GetEnumValue(*m, field);
          rtn = true;
          break;
        }
        else if((std::is_same_v<T, bool>) && field->type() == FieldDescriptor::TYPE_BOOL) {
          value = refl->GetBool(*m, field);
          rtn = true;
          break;

        }
        /*
        else if (field->type() == FieldDescriptor::TYPE_STRING) {
          value = refl->GetString(*m, field);
          rtn = true;
          break;
        }
        */
      }
  }
  return rtn;
} 
bool getMessageStringValue(std::shared_ptr<Message> m, const std::string &field_name, std::string &value, bool oneof_field = false)
 {
      const Descriptor *desc       = m->GetDescriptor();
      const Reflection *refl       = m->GetReflection();   
      int fieldCount= desc->field_count();
      //fprintf(stderr, "The fullname of the message is %s \n", desc->full_name().c_str());
      for(int i=0;i<fieldCount;i++)
      {
        const FieldDescriptor *field = desc->field(i);
        if (oneof_field) {
          // Get the oneof field descriptor
          const OneofDescriptor * oneof_descriptor = field->containing_oneof();
          if(oneof_descriptor != nullptr && refl->HasOneof(*m, oneof_descriptor))
          {
            field = refl->GetOneofFieldDescriptor(*m,oneof_descriptor);
          }
          else {
            continue;
          }
        }

        if(field->type() == FieldDescriptor::TYPE_STRING  && !field->is_repeated() && (field_name.empty() || field->name() == field_name))
        {
            value = refl->GetString(*m, field);
            return true;
        }

        //fprintf(stderr, "The name of the %i th element is %s and the type is  %s \n",i,field->name().c_str(),field->type_name());
      }
      return false;
} 
// Read the paramater string value
bool getMessageParamStringValue(std::shared_ptr<Message> m, const std::string &field_name, std::string &value)
{
      const Descriptor *desc       = m->GetDescriptor();
      const Reflection *refl       = m->GetReflection();   
      int fieldCount= desc->field_count();
 
      //fprintf(stderr, "The count of the param message: %i and the name: %s\n",fieldCount, desc->full_name().c_str());
      for (int i =0; i < fieldCount; i++) 
      {
        // Get the oneof field descriptor
        const OneofDescriptor * oneof_descriptor = desc->oneof_decl(i);
        if(oneof_descriptor != nullptr && refl->HasOneof(*m, oneof_descriptor))
        {
          const FieldDescriptor *field = refl->GetOneofFieldDescriptor(*m,oneof_descriptor);
          //fprintf(stderr, "The fullname of the param field is %s \n", field->name().c_str());
          if(field->type() == FieldDescriptor::TYPE_STRING  && !field->is_repeated() && field->name() == field_name)
          {
            value = refl->GetString(*m, field);
            return true;
          }
        }
      }
      return false;
 } 

template <typename T>
bool getMessageEnumList(std::shared_ptr<Message> message, const std::string &enum_list_name, T &type_value, std::unordered_map<std::string, T> &key_value) {
  bool rtn = false;
  const Descriptor *desc = message->GetDescriptor();
  const Reflection *refl = message->GetReflection();

  // Get the type value first
  if (getMessageFieldValue<T>(message,"",type_value,true)) {

    int fieldCount= desc->field_count();

    for(int i=0;i<fieldCount;i++)
    {
      const FieldDescriptor *field = desc->field(i);
      if(field->type() == FieldDescriptor::TYPE_MESSAGE  && field->name() == enum_list_name && field->is_repeated() )
      {
        // Iterate the repeated fields
        for (int j =0; j < refl->FieldSize(*message, field); j++ ) {
          const Message &mfield = refl->GetRepeatedMessage(*message, field, j);
          std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);

          // Get the key name
          if (std::string key; getMessageStringValue(*m, "key", key)) {           
            // Get the T value
            if (T value; getMessageFieldValue<T>(*m,"",value,true)) {
              key_value[key] = value;
              rtn = true;
            }
          }
        }
      }
    }
  }
  return rtn;
}
bool getMessageStringEnumList(std::shared_ptr<Message> message, const std::string &enum_list_name, std::string &type_value, std::unordered_map<std::string, std::string> &key_value) {
  bool rtn = false;
  const Descriptor *desc = message->GetDescriptor();
  const Reflection *refl = message->GetReflection();

  // Get the string value first
  if (getMessageStringValue(message,"string_value",type_value,true)) {

    int fieldCount= desc->field_count();

    for(int i=0;i<fieldCount;i++)
    {
      const FieldDescriptor *field = desc->field(i);
      if(field->type() == FieldDescriptor::TYPE_MESSAGE  && field->name() == enum_list_name && field->is_repeated() )
      {
        // Iterate the repeated fields
        for (int j =0; j < refl->FieldSize(*message, field); j++ ) {
          const Message &mfield = refl->GetRepeatedMessage(*message, field, j);
          std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);

          // Get the key name
          if (std::string key; getMessageStringValue(*m, "key", key)) {
            // Get the string value
            if (std::string value; getMessageStringValue(*m,"string_value",value,true)) {
              key_value[key] = value;
              rtn = true;
            }
          }
        }
      }
    }
  }
  return rtn;
}
// Return the parameter number enum list
template <typename T>
bool getMessageParamEnumList(std::shared_ptr<Message> message, const std::string &param_name, const std::string &name,std::map<std::string, std::unordered_map<std::string, T>> &enum_list)
{
      const Descriptor *desc       = message->GetDescriptor();
      const Reflection *refl       = message->GetReflection();   
      int fieldCount= desc->field_count();
      
      for(int i=0;i<fieldCount;i++)
      {
        const FieldDescriptor *field = desc->field(i);
        if(field->type() == FieldDescriptor::TYPE_MESSAGE  && field->name() == param_name && field->is_repeated() )
        {
          //fprintf(stderr, "The count of the param list message: %i and the name: %s\n",refl->FieldSize(*message, field), field->name().c_str());
          for (int j =0; j < refl->FieldSize(*message, field); j++ ) {
            const Message &mfield = refl->GetRepeatedMessage(*message, field, j);
            std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);
            
            T typeValue;
            std::unordered_map <std::string, T> keyValue;
            if (getMessageEnumList<T>(*m, "enum_list", typeValue, keyValue)) {
              const std::string enumName = name +  "_" + std::to_string(typeValue);
              std::unordered_map <std::string, T> reversedKeyValue;
              for (const auto &[key, value] : keyValue) {
                reversedKeyValue[key] = value;
              }
              enum_list[replaceSpeicalWithUnscoreChar(enumName)] = reversedKeyValue;
            }
          }
        }
      }
      return false;
}
// Return the string parameter enum list 
bool getMessageParamStringEnumList(std::shared_ptr<Message> message, const std::string &param_name, const std::string &name,std::map<std::string, std::unordered_map<std::string, std::string>> &enum_list)
{
      const Descriptor *desc       = message->GetDescriptor();
      const Reflection *refl       = message->GetReflection();   
      int fieldCount= desc->field_count();
      
      for(int i=0;i<fieldCount;i++)
      {
        const FieldDescriptor *field = desc->field(i);
        if(field->type() == FieldDescriptor::TYPE_MESSAGE  && field->name() == param_name && field->is_repeated() )
        {
          //fprintf(stderr, "The count of the param list message: %i and the name: %s\n",refl->FieldSize(*message, field), field->name().c_str());
          for (int j =0; j < refl->FieldSize(*message, field); j++ ) {
            const Message &mfield = refl->GetRepeatedMessage(*message, field, j);
            std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);
            
            std::string typeValue;
            std::unordered_map <std::string, std::string> keyValue;
            if (getMessageStringEnumList(*m, "enum_list", typeValue, keyValue)) {
              const std::string enumName = name +  "_" + typeValue;
              std::unordered_map <std::string, std::string> reversedKeyValue;
              for (const auto &[key, value] : keyValue) {
                reversedKeyValue[key] = value;
              }
              enum_list[replaceSpeicalWithUnscoreChar(enumName)] = reversedKeyValue;
            }
          }
        }
      }
      return false;
}
// Return the number value enum list
template <typename T>
bool getMessageValueEnumList(std::shared_ptr<Message> message, const std::string &value_name, const std::string &name,std::map<std::string, std::unordered_map<std::string, T>> &enum_list)
{
      const Descriptor *desc       = message->GetDescriptor();
      const Reflection *refl       = message->GetReflection();   
      int fieldCount= desc->field_count();
      
      for(int i=0;i<fieldCount;i++)
      {
        const FieldDescriptor *field = desc->field(i);
        if(field->type() == FieldDescriptor::TYPE_MESSAGE  && field->name() == value_name && !field->is_repeated() )
        {
          const Message &mfield = refl->GetMessage(*message, field);
          std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);
            
          T typeValue;
          std::unordered_map <std::string, T> keyValue;
          if (getMessageEnumList<T>(*m, "enum_list", typeValue, keyValue)) {
            std::unordered_map <std::string, T> reversedKeyValue;
            for (const auto &[key, value] : keyValue) {
                reversedKeyValue[key] = value;
            }
            enum_list[replaceSpeicalWithUnscoreChar(name)] = reversedKeyValue;
          }
        }
      }
      return false;
}
// Return the string value enum list
bool getMessageValueStringEnumList(std::shared_ptr<Message> message, const std::string &value_name, const std::string &name,std::map<std::string, std::unordered_map<std::string, std::string>> &enum_list)
{
      const Descriptor *desc       = message->GetDescriptor();
      const Reflection *refl       = message->GetReflection();   
      int fieldCount= desc->field_count();
      
      for(int i=0;i<fieldCount;i++)
      {
        const FieldDescriptor *field = desc->field(i);
        if(field->type() == FieldDescriptor::TYPE_MESSAGE  && field->name() == value_name && !field->is_repeated() )
        {
          const Message &mfield = refl->GetMessage(*message, field);
          std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);
            
          std::string typeValue;
          std::unordered_map <std::string, std::string> keyValue;
          if (getMessageStringEnumList(*m, "enum_list", typeValue, keyValue)) {
            std::unordered_map <std::string, std::string> reversedKeyValue;
            for (const auto &[key, value] : keyValue) {
                reversedKeyValue[key] = value;
            }
            enum_list[replaceSpeicalWithUnscoreChar(name)] = reversedKeyValue;
          }
        }
      }
      return false;
}
// Read the parameter name
bool getMessageParamName(std::shared_ptr<Message> message, const std::string &param_name, std::string &name)
{
      const Descriptor *desc       = message->GetDescriptor();
      const Reflection *refl       = message->GetReflection();   
      int fieldCount= desc->field_count();
      //fprintf(stderr, "The count of the data message: %i and the name: %s\n",fieldCount, desc->name().c_str());
      for(int i=0;i<fieldCount;i++)
      {
        const FieldDescriptor *field = desc->field(i);
        if(field->type() == FieldDescriptor::TYPE_MESSAGE  && field->name() == param_name && field->is_repeated() )
        {
          //fprintf(stderr, "The count of the param list message: %i and the name: %s\n",refl->FieldSize(*message, field), field->name().c_str());
          for (int j =0; j < refl->FieldSize(*message, field); j++ ) {
            const Message &mfield = refl->GetRepeatedMessage(*message, field, j);
            std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);
            if(getMessageStringValue(*m,"string_value", name, true)) {
              return true;
            };
          }
        }
      }
      return false;
 } 
// Generate the number enum list
template <typename T>
void generateEnumList(const std::map<std::string, std::unordered_map<std::string, T>> &enum_list) {
    // Generate the enum header
  if (std::string value_type_name; getDataTypeName<T>(value_type_name)) {
    for ( auto const& [enum_name, key_value]:enum_list) {

      if (value_type_name == "float" || value_type_name == "double") {
        std::stringstream mapStream;

        // Create the map header
        mapStream << "static std::map<uint32_t," + value_type_name + "> kMap" << enum_name << " = {" << std::endl;

        // Generate the enum header
        std::cout << "// " << enum_name << ": enum and map list" << std::endl;
        const std::string uint32_header = "enum class Enum" + enum_name + ": uint32_t {";
        std::cout << uint32_header << std::endl;
        uint i= 0;
        for (auto const& [key, value]: key_value) {
          // Generate the enum body
          const std::string enumName = "ENUM_" + convertNameString(enum_name + "_" + key) + " = " + std::to_string(i) + ",";
          std::cout << enumName << std::endl;
          // create the map body
          mapStream << "{" << i << "," << value << "}," << std::endl;
          i++;
        }
        // Generate the end of enum list
        std::cout << "};" << std::endl << std::endl;

        // Create the end of map
        mapStream << "};";
        // Output the whole map
        std::cout << mapStream.str() << std::endl << std::endl;
      }
      else {
        // Generate the enum header
        std::cout << "// " << enum_name << ": enum list" << std::endl;
        const std::string enum_header = "enum class Enum" + enum_name + ": " + value_type_name + " {";
        std::cout << enum_header << std::endl;

        for (auto const& [key, value]: key_value) {
          // Generate the enum body
          const std::string enumName = "ENUM_" + convertNameString(enum_name + "_" + key) + " = " + std::to_string(value) + ",";
          std::cout << enumName << std::endl;
        }
        // Generate the end of enum list
        std::cout << "};" << std::endl << std::endl;       
      }
    }
  }
}

// Generate the string type enum list
void generateStringEnumList(const std::map<std::string, std::unordered_map<std::string, std::string>> &enum_list) {

  for ( auto const& [enum_name, key_value]:enum_list) {

    std::stringstream mapStream;

    // Create the map header
    mapStream << "static std::map<uint32_t,const char*> kMap" << enum_name << " = {" << std::endl;

    // Generate the enum header
    std::cout << "// " << enum_name << ": enum and map list" << std::endl;
    const std::string uint32_header = "enum class Enum" + enum_name + ": uint32_t {";
    std::cout << uint32_header << std::endl;
      uint i= 0;
      for (auto const& [key, value]: key_value) {
        // Generate the enum body
        const std::string enumName = "ENUM_" + convertNameString(enum_name + "_" +  key) + " = " + std::to_string(i) + ",";
        std::cout << enumName << std::endl;
        // create the map body
        mapStream << "{" << i << ",\"" << value.c_str() << "\"}," << std::endl;
        i++;
      }
      // Generate the end of enum list
      std::cout << "};" << std::endl << std::endl;

      // Create the end of map
      mapStream << "};";
      // Output the whole map
      std::cout << mapStream.str() << std::endl << std::endl;
    }
}
/**
 * 
 */
void genertaeFileHeader() {
      const auto header =   R"(//--------------------------------------------------------------------------------------------------------------------//
//! 
//  Generated header file from JSON. DO NOT EDIT!
//! 
//--------------------------------------------------------------------------------------------------------------------//

#pragma once
#include <string>
#include <map>

namespace cdiProfile {)";
  std::cout << header << std::endl << std::endl;
}
/**
 * Convert between JSON and protobuf.
 *
 * The behavior of this process will vary depending on the name that the
 * executable is invoked under.
 *   JsonToProto will assume the input is JSON and write binary protobuf to
 *   stdout.
 *   ProtoToJson will assume the input is Proto and write JSON to stdout.
 *
 * If [data] is not provided as an argument, input is read from stdin.
 *
 * If [data] is provided, it is interpreted as a filename if it is prefixed
 * with the `@` symbol, and otherwise as literal data.
 *   For ToProto, literal data is interpreted as JSON.
 *   For ToJson, literal data is interpreted as base64 encoded protobuf.
 */
int main(int argc, char** argv){
  // Check if options need to be prefixed from an env var.
  char* prefixedArguments = getenv("PROTO_JSON_OPTIONS");
  while (prefixedArguments) {
    wordexp_t word_expansion;

    int error = wordexp(prefixedArguments, &word_expansion, 0);
    if (error) {
      fprintf(stderr, "Failed to expand PROTO_JSON_OPTIONS '%s'. Ignoring it.", prefixedArguments);
      break;
    }
    int oldArgc = argc;
    char** oldArgv = argv;

    argc += word_expansion.we_wordc;
    argv = (char**) malloc(argc * sizeof(char*));
    argv[0] = oldArgv[0];
    // Copy the new arguments in front.
    for (int i = 0; i < word_expansion.we_wordc; i++) {
      argv[i+1] = strdup(word_expansion.we_wordv[i]);
    }

    // Copy the original arguments afterwards.
    for (int i = 1; i < oldArgc; i++) {
      argv[i + word_expansion.we_wordc] = oldArgv[i];
    }

    wordfree(&word_expansion);
    break;
  }

  Options options = parseArguments(argc, argv);

  // Construct the list of all proto file names we will use.
  std::vector<std::string> allFilenames;
  if (options.protoFiles.empty()) {
    // If the user did not specify proto files, then parse all file names from
    // the filesystem, since SourceTreeDescriptorDatabase does not appear to
    // implement FindAllFileNames.
    for (const char* importPath: options.protoPaths) {
      std::filesystem::path protoDirPath(importPath);
      std::filesystem::recursive_directory_iterator it(protoDirPath,
          std::filesystem::directory_options::follow_directory_symlink);
      for (const std::filesystem::directory_entry& dir_entry : it) {
        if (dir_entry.is_regular_file()) {
          auto path = dir_entry.path();
          if (path.extension().string() == ".proto") {
            // We need to strip out the first directory because the
            // recursive_directory_iterator includes the name of the import path
            // and the proto tools assume paths relative to the import path.
            allFilenames.push_back(path.lexically_relative(protoDirPath));
          }
        }
      }
    }
  } else {
    // The user specified proto files so just use those. Note that we assume
    // the user has given filenames relative to at least one of the import
    // paths, just like protoc.
    for (const char* filename : options.protoFiles) {
      allFilenames.push_back(filename);
    }
  }

  // Construct source tree and importer for source files.
  DiskSourceTree diskSourceTree;
  for (const char* importPath: options.protoPaths) {
    diskSourceTree.MapPath("", importPath);
  }

  class ErrorReporter: public MultiFileErrorCollector {
    public:
      virtual void AddError(const std::string & filename, int line, int column, const std::string & message) {
        std::cerr << "Error occured for " << filename << ":" << line << ":" <<
          column  << " " << message << std::endl;
      }
  } errorReporter;

  Importer importer(&diskSourceTree, &errorReporter);

  // Map of fully-qualified message names to packages.
  std::map<std::string, const Descriptor*> messageDescriptors;

  // Add message descriptors from proto files.
  for (std::string& filename: allFilenames) {
    const FileDescriptor* fd = importer.Import(filename);
    if (fd == NULL) {
      std::cerr << "Encoutered errors when importing file " << filename << std::endl;
      exit(1);
    }
    importFileDescriptor(fd, messageDescriptors);
  }

  // Add message descriptors from descriptor sets iff the are no protoPaths
  // specified. The behavior of ignoring descriptorSets when protoPaths is
  // specified is consistent with `protoc` behavior, and also removes any
  // potential risks associated with using descriptors from multiple pools at
  // the same time.
  DescriptorPool pool;
  if (options.protoPaths.empty()) {
    for (int i = 0; i < options.descriptorSets.size(); i++) {
      std::string descriptorSetBytes = readFile(options.descriptorSets[i]);
      FileDescriptorSet proto_files;
      proto_files.ParseFromString(descriptorSetBytes);
      for (int j = 0; j < proto_files.file_size(); j++) {
        const FileDescriptor* fd = pool.BuildFile(proto_files.file(j));
        importFileDescriptor(fd, messageDescriptors);
      }
    }
  }

  // Search for a descriptor based on the message name.
  std::vector<std::string> matches;
  for (auto message: messageDescriptors) {
    // Exact match has higher priority than partial matches.
    // This is necessary for correct behavior when one proto's full name is an
    // exact subset of another.
    if (message.first == options.messageName) {
      matches.clear();
      matches.push_back(message.first);
      break;
    }

    if (message.first.find(options.messageName) != std::string::npos) {
      matches.push_back(message.first);
    }
  }

  if (matches.size() == 0) {
    std::cerr << "Failed to find message " << options.messageName << std::endl;
    return 1;
  }
  if (matches.size() > 1) {
    std::cerr << "Found multiple messages matching " << options.messageName << std::endl;
    for (std::string& match: matches) {
      std::cerr << '\t' << match << std::endl;
    }
    return 1;
  }

  // Construct a message from the given descriptor. This name must exclude the
  // package.
  const Descriptor* messageDescriptor = messageDescriptors[matches[0]];
  if (options.verbose) {
    std::cerr << messageDescriptor->DebugString() << std::endl;
  }
  DynamicMessageFactory dynamicMessageFactory;
  Message* message = dynamicMessageFactory.GetPrototype(messageDescriptor)->New();

  Status conversionStatus;
  if (options.convertType == EnumConvertType::PROTO_TO_JSON) {
    bool parseSuccessful;
    // Converting protobuf to JSON
    if (options.data) {
      if (options.data[0] == '@') {
        // Read binary from file
        FILE* protoFile = fopen(options.data + 1, "rb");
        parseSuccessful = message->ParseFromFileDescriptor(fileno(protoFile));
        fclose(protoFile);
      } else {
        // Interpret as base64 encoded binary protobuf.
        std::string binaryProto;
        if (!Base64Unescape(options.data, &binaryProto)) {
          std::cout << "Failed to decode base64." << std::endl;
          exit(1);
        }
        parseSuccessful = message->ParseFromString(binaryProto);
      }
    } else {
      // Read binary from stdin.
      parseSuccessful = message->ParseFromIstream(&std::cin);
    }
    if (!parseSuccessful) {
      std::cout << "Failed to parse protobuf message." << std::endl;
      exit(1);
    }

    std::string jsonOutput;
    JsonPrintOptions printOptions;
    printOptions.preserve_proto_field_names = true;
    printOptions.always_print_primitive_fields = false;
    printOptions.add_whitespace = true;
    printOptions.always_print_enums_as_ints = false;
    conversionStatus = MessageToJsonString(*message, &jsonOutput, printOptions);
    if (!conversionStatus.ok()) {
      std::cout << conversionStatus << std::endl;
      exit(1);
    }
    std::cout << jsonOutput << std::endl;
  } 
  else if (options.convertType == EnumConvertType::JSON_TO_PROTO) {
    //  Converting JSON to protobuf
    if (options.data) {
      if (options.data[0] == '@') {
        // Read JSON from file
        std::ifstream jsonFile(options.data + 1);
        std::stringstream buffer;
        buffer << jsonFile.rdbuf();
        conversionStatus = JsonStringToMessage(buffer.str(), message);
      } else {
        // Interpret as JSON Text
        conversionStatus = JsonStringToMessage(options.data, message);
      }
    } else {
      // Read JSON from stdin.
      std::stringstream buffer;
      buffer << std::cin.rdbuf();
      conversionStatus = JsonStringToMessage(buffer.str(), message);
    }
    if (!conversionStatus.ok()) {
      std::cout << conversionStatus << std::endl;
      exit(1);
    }
    message->SerializeToOstream(&std::cout);
  } else if (options.convertType == EnumConvertType::JSON_TO_HEADER) {
  
    //  Converting JSON to protobuf
    if (options.data) {
      if (options.data[0] == '@') {
        // Read JSON from file
        std::ifstream jsonFile(options.data + 1);
        std::stringstream buffer;
        buffer << jsonFile.rdbuf();
        conversionStatus = JsonStringToMessage(buffer.str(), message);
      } else {
        // Interpret as JSON Text
        conversionStatus = JsonStringToMessage(options.data, message);
      }
    } else {
      // Read JSON from stdin.
      std::stringstream buffer;
      buffer << std::cin.rdbuf();
      conversionStatus = JsonStringToMessage(buffer.str(), message);
    }
    if (!conversionStatus.ok()) {
      std::cout << conversionStatus << std::endl;
      exit(1);
    }

    const Reflection *refl = message->GetReflection();
    int fieldCount= messageDescriptor->field_count();
 
    //fprintf(stderr, "The fullname of the message is %s \n", messageDescriptor->full_name().c_str());
    for(int i=0;i<fieldCount;i++)
    {
        const FieldDescriptor *field = messageDescriptor->field(i);

        if(field->type()==FieldDescriptor::TYPE_MESSAGE && field->is_repeated()){
          // Generate the file header
          genertaeFileHeader();
          std::string structNameStr;
          if (options.structName != NULL) {
            structNameStr = std::string(options.structName);
          }
          else {
            structNameStr =  std::string(options.messageName);           
          }
          // Generate the enum header
          const std::string enumHeader = "enum class Enum" + structNameStr + ": uint32_t {";
          std::cout << enumHeader << std::endl;

          // Uppercase the message name
          auto msgNameStr = convertNameString(structNameStr);

          std::map<std::string, std::unordered_map<std::string, uint32_t>> uint32EnumList;
          std::map<std::string, std::unordered_map<std::string, int32_t>> int32EnumList;
          std::map<std::string, std::unordered_map<std::string, std::string>> stringEnumList;
          std::map<std::string, std::unordered_map<std::string, float>> floatEnumList;

          if (std::string(options.messageName) == "SettingList") {
            // Store the map data
            std::stringstream mapStream;
            // Generate the map header
            mapStream << "static std::map<uint32_t,const char*> kMap"
            << structNameStr << " = {" << std::endl;

            //std::cerr << refl->FieldSize(*message, field) << std::endl;
            for (int j =0; j < refl->FieldSize(*message, field); j++ ) {
           
              const Message &mfield = refl->GetRepeatedMessage(*message, field, j);

              std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);

              std::string value;
              if (getMessageStringValue(*m,"name",value)) {
                // Generate the enum body
                const std::string enumName = "ENUM_"  + msgNameStr + "_" + convertNameString(value) + " = " + std::to_string(j) + ",";
                std::cout << enumName << std::endl;

                // Generate the map body
                mapStream << "{" << j << ",\"" << value << "\"}," << std::endl;

                // Scan the enum list with uint32_t and int32_t types
                getMessageValueEnumList<uint32_t>(*m, "value", value,uint32EnumList);
                getMessageValueEnumList<int32_t>(*m, "value", value,int32EnumList);
                getMessageValueEnumList<float>(*m, "value", value,floatEnumList);
                getMessageValueStringEnumList(*m, "value", value,stringEnumList);
              }
            } 
            // Generate the end of enum list
            std::cout << "};" << std::endl << std::endl;

            // Generate the end of map
            mapStream << "};";
            std::cout << mapStream.str() << std::endl << std::endl;

            // Generate the enum list
            generateEnumList<uint32_t>(uint32EnumList);
            generateEnumList<int32_t>(int32EnumList);
            generateEnumList<float>(floatEnumList);
            generateStringEnumList(stringEnumList);
          }
          else if (std::string(options.messageName) == "EventList") {
            // Store the map data
            std::stringstream mapStream;

            // Generate the map struct header
            const std::string dataNameStr = "Struct" + structNameStr;
            mapStream << "struct " << dataNameStr << " {" << std::endl;
            mapStream <<"uint32_t type;" << std::endl;
            mapStream <<"uint32_t id;" << std::endl;
            mapStream <<"const char* name;" << std::endl;
            mapStream << "};" << std::endl << std::endl;
        
            // Generate the map header
            mapStream << "static std::map<uint32_t, struct " << dataNameStr << "> kMap"
            << structNameStr << " = {" << std::endl;

            //std::cerr << refl->FieldSize(*message, field) << std::endl;
            for (int j =0; j < refl->FieldSize(*message, field); j++ ) {
           
              const Message &mfield = refl->GetRepeatedMessage(*message, field, j);

              std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);

              std::string name;
              uint32_t type;
              uint32_t id;
              if (getMessageStringValue(*m,"name",name) 
                && getMessageFieldValue<uint32_t>(*m, "type", type)
                && getMessageFieldValue<uint32_t>(*m, "id", id)) {
                // Generate the enum body
                const std::string enumName = "ENUM_"  + msgNameStr + "_" + convertNameString(name) + "_" + std::to_string(type) + " = " + std::to_string(j) + ",";
                std::cout << enumName << std::endl;

                // Generate the map body
                mapStream << "{" << j << ", {" << type << "," << id 
                << ",\"" << name << "\"}}," << std::endl;
              } 
            }
            // Generate the end of enum list
            std::cout << "};" << std::endl << std::endl;

            // Generate the end of map
            mapStream << "};";
            std::cout << mapStream.str() << std::endl << std::endl;

          }
          else if (const std::string protoMsgName = std::string(options.messageName); 
          ( protoMsgName== "ActionList") || (protoMsgName == "NotificationList")) {

            for (int j =0; j < refl->FieldSize(*message, field); j++ ) {
           
              const Message &mfield = refl->GetRepeatedMessage(*message, field, j);

              std::shared_ptr<Message> *m = createMessageSharedPtr(mfield);
              
              uint32_t code;
              std::string paramName;
              if (getMessageFieldValue<decltype(code)>(*m,"code",code) && getMessageParamName(*m,"param_list", paramName)) {
                // Generate the enum body
                const std::string enumName = "ENUM_"  + msgNameStr + "_" + convertNameString(paramName) + " = " + std::to_string(code) + ",";
                std::cout << enumName << std::endl;

                getMessageParamEnumList<uint32_t>(*m, "param_list", paramName,uint32EnumList);
                getMessageParamEnumList<int32_t>(*m, "param_list", paramName,int32EnumList);
                getMessageParamEnumList<float>(*m, "param_list", paramName,floatEnumList);
                getMessageParamStringEnumList(*m, "param_list", paramName,stringEnumList);
              }
            }
            // Generate the end of enum code list
            std::cout << "};" << std::endl << std::endl;

            // Generate the enum list
            generateEnumList<uint32_t>(uint32EnumList);
            generateEnumList<int32_t>(int32EnumList);
            generateEnumList<float>(floatEnumList);
            generateStringEnumList(stringEnumList);
          }
          // End of namespace
          std::cout << "} // namespace cdiProfile" << std::endl;
        }
    }
    
    //message->SerializeToOstream(&std::cout);

  }
  // Give a hint about a different command that would run faster next time.
  if (options.protoFiles.empty() && !options.protoPaths.empty()) {
    fprintf(stderr, "For faster conversion of this message, add \e[1m-P %s\e[m to the command invocation.\n",
       messageDescriptor->file()->name().c_str());
  }
}
